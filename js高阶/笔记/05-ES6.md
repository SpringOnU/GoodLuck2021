**ECMAScript** 

**一项脚本语言的标准化规范**

# 一、 变量

## 1. let

+ 块级作用域（大括号的作用域）

  ```js
  		if (true) {
  			let a = 10;
  		}
  		console.log(a);		// a is not defined
  ```

+ 不存在变量提升

  ```js
  		console.log(a);		// a is not defined
  		let a = 10;
  ```

+ 暂时性死区

  ```js
  		var num = 100;
  		if(true) {
  			console.log(num);		// Cannot access 'num' before initialization 变量没有定义
  			let num = 2;		// 暂时性死区 num会和 if 绑定在一起
  		}
  		console.log(num);		// 100
  ```

  

![](E:\EPInterest\js高阶\笔记\img\Screenshot_20210122_161300_com.baidu.netdisk_edit.jpg)

![](E:\EPInterest\js高阶\笔记\img\Screenshot_20210122_161436_com.baidu.netdisk_edit.jpg)

## 2. const

+ 块级作用域

  ```js
  		if (true) {
  			const a = 10;
  		}
  		console.log(a);		// a is not defined
  ```

+ 声明变量时必须赋值

  ```js
  		const i;		// Missing initializer in const declaration
  ```

## 3. var let const 的区别

![](E:\EPInterest\js高阶\笔记\img\Screenshot_20210122_162605_com.baidu.netdisk_edit.jpg)

> 红宝石总结区别
>
> |                                  | var定义变量                              | let定义变量        | const定义常量                                                |
> | -------------------------------- | :--------------------------------------- | ------------------ | ------------------------------------------------------------ |
> | 作用域                           | 函数作用域：局部变量：函数退出时就会销毁 | 块作用域（大括号） | 块作用域                                                     |
> | 声明提升：函数定义会提升到顶部   | ✅                                        | ❌暂时性死区        | ❌                                                            |
> | 全局作用域下成为window对象的属性 | ✅                                        | ❌                  | ❌                                                            |
> | 冗余声明                         | ✅                                        | ❌                  | ❌                                                            |
> |                                  |                                          |                    | 1. 声明变量的同时也必须初始化变量 2. 可以修改其内部属性，但其指向的地址不可修改 |
> | 迭代变量                         | ✅                                        | ✅                  | ❌                                                            |

# 二、解构赋值

+ 数组解构允许我们按一一对应的关系从数组中提取 然后将值赋给变量

  ```js
  let [a, b, c] = [1, 2, 3];
      console.log(a)		// 1
      console.log(b)		// 2
      console.log(c)		// 3
      console.log(e)		// undefined
  ```

# 三、 箭头函数

新增定义函数的方法

简化函数定义语法

` () => {}`

` const fn = () => {}`

形参 => 函数体

```js
		const fn = () => {
			console.log(123)
		}
		fn();
```

+ **函数体中只有一句代码 并且代码的执行结果就是函数的返回值** 函数的大括号可以省略

  ```js
  		const sum = (n1, n2) => n1 + n2;
  		result = sum(1, 2);
  		console.log(result);		// 3
  ```

+ **形参只有一个** 可以省略小括号

  ```js
  		const sum = n => alert(n);
  		sum(3);
  ```

## 1. this

箭头函数不绑定this，箭头函数没有自己的this关键字

**箭头函数中的this指向箭头函数定义位置中的this**

```js
		function fn () {
			console.log(this);		//  {name: "hii"}
			return () => {
				console.log(this)	//  {name: "hii"}
			}
		}
		
		const obj = {name: 'hii'};

		const resFn = fn.call(obj);	//切换this指向 使fn中的this指向obj的对象
									// 用resFn接收fn的返回结果
		resFn();
```

```js
		var obj = {
			age: 20,
			say: () => {
				alert(this.age)		// this指向的是箭头函数定义区域的this 
									// 当前函数定义在obj对象里面 但obj是一个对象 无法产生作用域
									// 所以这个箭头函数定义在了全局作用域下 即windows
									// 所以这个this函数定义在了windows下 windows没有age属性 即undefined
			}
		}

		obj.say();		// undefined
```



# 四、剩余参数

剩余参数语法允许我们**将一个不定数量的参数表示为一个数组**









